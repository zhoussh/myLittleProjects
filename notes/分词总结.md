##分词的总结
###基本分词
####总体流程
回过头来，再想想这个流程，我们首先输入一句话，将这一句话str送入到Graph类里面去，在这个类里面，会将这句话str打散成一个字符串，graph.chars[]，然后将graph.chars[]送入到GetWords里面，作出歧义处理。那么如何做这个歧义处理呢？
#####歧义处理
######SmartGetWord类
很明显歧义处理的话，就需要歧义字典，这里用了一个ambiguityForest作为歧义字典，说白了就是一个数组，这个数组实现了Comparable接口，这样容易实现二分查找。我们先来看看这个数组，数组里面有两个变量需要我们注意到，字符和状态。这个凭借着这两个变量做到了添加词语（keyword）和获得歧义的词语（getBranch()）。这个数组程序称之为SmartForest类，然后将这个SmartForest的调用是在SmartGetWord类里面，都是Smart家族的感觉。这个类里面主要完成歧义的词的输出，输入的是一个歧义字典和一句被打散的字符串。SmartWord里面有两个类比较重要，一个是allWords()，一个是frontWord()。allWords()是干什么的呢？首先遍历了整个字符数组，然后一直遇到里面嵌套的循环，这里面嵌套的循环需要看一下，看起来救市一个返回词的意思，重要的是对tempJLen这个变量的理解，如果取出一个词语还可以继续，那么就可以继续下去从结束的位置开始，也就不用从头开始再遍历一遍了，所以tempJLen这个变量是用来记录取词的长度的，如果确定是最后一个字了，就不用记录了，所以就置为空。内层循环结束后，回到外层循环，也没啥好说的了。连续调用这个函数，那么就会取出所有的歧义字典中所有的相关词，如果有些词不再这个歧义字典里面，那该咋办呢？就不做任何处理，直接返回空。
再看看frontWord，这个名字听着就像是取出一句话中最前面的一个词。程序一开始，依旧是遍历，遍历完之后，这里依旧有一个tempOffe的变量，作用是一样的。看起来跟上一个程序没什么区别，那我们就找出区别。那就是多了一个isBack变量，这个变量出现了，预示着要从头开始取词了。也就是说，前面的提取效果根本就不对，为何不正确呢？是因为提取到句子结束了。换句话说，本来取词取得好好的，发现状态还没有到3，整个句子就结束了，那么就需要检测，如果已经发现了2,那么就此直接返回，并更新相关变量，如果并没有2,则意味着没有遇到2,也没有遇到3，则this.isBack = false，说明无法执行if(this.isback)这个里面的语句，则直接可以跳过了，说明举例里面并没有歧义字典里面的词。
歧义处理结束了，返回的是偏移值，也就是在这句话里面，哪个地方开始有歧义字典里面的词语出现的地方。好了，歧义词语处理完毕之后，就回到了另外一个程序中了。
######analysis()方法
首先返回的歧义处理的结果之后，发现了歧义出现的偏移量要大于startOffe，也就意味着我们需要在StartOffe与gw.offe之间处理。相反，如果StartOffe要大于gw.Offe就说明一开始就有歧义值需要处理。处理完之后，再将gw.offe赋值给StartOffe，这里有个param变量，希望大家不要把它给搞成参数了，这个命名实在是不好理解，其实查看之后发现这个param可以是字符，也可以是字符串，所以在SmartForest这个类里面用了泛型表示。所以这里返回了params直接可以加入到graph中。
接下来就分析对于没有歧义的字符怎么办，这个解决方法就是analysis()方法，输入就是哪个图，以及这句话的分词的区间。打开这个程序一看，好吧，又是遍历，遍历中识别出是英文，是数字，还是补充字符，还是汉字，如果是汉字的话，那么进入default处理，那么就看看如何处理吧。
首先看看这个字符在不在系统的字典中，如果存在，那么就将end++，一直到不存在字典中或者超过取词范围了，得到了start和end值，就将这些东西赋值给gwi.setChars()，如果仅仅只有一个字符，那就直接丢给gp.addTerm()。好了，这就是这个方法里面比较重要的东西了，这东西就是取出一个词，然后丢到gp.addTerm中，一直循环到所有的词结束。这个取词的方法就是在字典中寻找，如果存在了，就按照状态寻找，如果是找到了状态2,那么还要继续寻找，有些值不能变，一直到了状态3,才可以将有些值变化。继续将返回的字符串放到gp中去，如果没有出现同样也会放到里面去。
######insertTerm()方法
这个方法就需要区别出terms[i+1]和term[i].next()的区别了。为此，我们需要先看看next()方法是啥？terms是一个数组无疑了，那么这个数组和terms是通过addTerm()之间产生关系的，这样我们很容易追溯到TermUtil.insertTerm()这个方法，而addTerm这个方法又是不断在产生取词的时候和歧义分析的时候用到的，那么我们就要仔细看看这个方法做了哪些事。
首先将Term放到Terms[i]中，然后如果程序至此结束，那就是一个数组了。继续往下看，如果发现这个Term在数组中已经存在了，那么就会有很多有趣的情况需要处理，数组中存在的那个term用self表示，输入的term就用term表示。首先如果是等长的那话，那么区分为可以替代，还是累计加分。如果不是等长，那么需要将term的next()连接到self,这里面对应这一个词没有分完，还可以继续分。
再继续往下看，下面这个while循环作用就在于将term和self链表放在一起，如何放呢？根据长度放，长度长的放在料表的后面，长度短的，放在链表的前面。
######optimalRoot()
继续上面的，如果解决完歧义，并且完层了填词和链表插入等动作，那么接下来就是程序就调用了optimalRoot()方法，看看这个方法。首先需要看得是逆序寻找，每次都是找到from，然后在from和to之间，去掉重复的，并且断开数组里面的链表，这里默认了取链表中最长的那个term。一次继续喜爱去，最后返回root即可。
######总结
至此最简单的分词方法就说完了。
###字典分词
看这个程序要注意与基本分词有什么区别。首先映入眼帘的是一个getResult()方法，卧槽！一看就是获得结果的方法啊。这里面定义了一个实例，并且定义了这个方法。这个方法首先就设置了用户自定义字典优先的方法，定义完自定义字典以后，就可以像基本分词一样了，取词，用最大长度分词。然后分词出来的graph再进行用户自定义字典的识别，数字识别，人名识别。值得注意的是，renminbi之别以后，都会有一个方法是wallkPathByScore()。所以看到这丽，我们就一次看用户自定义字典识别的方法，人名识别的方法和walkPathByScore()等方法。
######recognition()方法
这里面最重要的莫过于recognition()方法了。一就是遍历字典中，一看就应该有很多字典的感觉，打开UserDefineLibrary这个类一看，确实是有两个字典，一个是用户自定义的补充字典，另一个是用户的歧义处理字典。这个字典里面的元素比价容易理解，单词和词频。继续看recognition()方法，遍历整个一个terms数组，并获取在字典中的位置，发现如果状态是3,则说明从字典中获取词性，词频，并且形成一个新的term，如果是2,同样，也是差不多的操作。所以看起来这个方法就从字典中获取词的一些性质的方法。
######rmLittlePath()方法
好了，获得了词频，词性等方法，就有了计算路径分数的可能了。这个方法是用来删除最短节点的，删除的依据就是是否存在交叉，在i元素，我们取出来一个元素，然后在i+1一直到maxTo之间遍历，如果存在一个元素i+k的最大term的toValue值大于maxTo则说明存在交叉，否则不存在交叉，如果不存在交叉，那么里面的所有的term就可以销毁啦，否则就要继续设置i值，从maxTo开始。这个方法就是删除了内部term的一个方法。
######walkPathByScore()方法
这个方法就比较简单了，因为我以前看过。遍历打分，从节点BEGIN开始，先是遍历遍历数组里面每个元素里面的链表元素到to的分数，遍历完之后，再对数组中每个元素到to值的分数。这样下来，都可以完成整个数组的遍历了分数了。遍历打分之后，调用了optimalRoot()方法，切断了内部较小的term。
######userDefineRecognition()方法
首先删除了内部较小的term到to之间的路径，然后遍历打分，之后再将里面的一些无用的term元素里面的链表元素删除掉。删除了之后，再执行一步删除最小路径操作。
为何程序要这么设计呢？这是因为第一步删除最小路径之后，会有