#ansj_seg分词源程序解读

##分词主类们的介绍
打开目录，首先从Analysis这个抽象类开始介绍。
####Analysis类
这个类是所有分词都需要继承的类，里面充满了各种分词方法的抽象出来的方法和变量，首先就是偏移量，分词类的实现，
#####GetWordsImpl
首先看看这个类。看类首先看变量，变量看完了就看构造函数。明显这个构造函数就是传入了一个句子进去了，并且这个句子的变量名就是str,好了有了输入了，就可以追踪这个输入继续下去了。这个句子在setChars中被分拆成几个变量，数组chars，checkValue应该就是双数组里面用到的吧，start和end都是表示句子的开始和结束偏移量，并且将偏移量置赋值给i。后来继续声明了变量，包括本类的，也包括双数组里面所需要的base，check所需要的。
接下来遇到了allwords方法，这个方法里面有getStatement()方法，这个方法是由baseValue得到获得这个字符的状态，但是在获得状态的时候，需要记得将前一个baseValue保存在checkValue里面，获得新的baseValue,新的baseValue是在上一个字符的基础上加上本身字符的编码的获得的，然后对新的baseValue获得状态。获得这个状态以后，接下来就是状态机连续判断的问题了。
首先如果这个字符不存在字典里，咋办？那就中断取词了。我一直认为这个取词程序比注释中用分词要好理解的多。如果状态是1的话，就继续执行这个循环，但是i的值变化了，一直遇到了2或者3。如果遇到了返回的状态是2,那么我们就需要把偏移量记录下来，把baseValue也记录下来。返回状态是3的话，那就是可以完确定是一个词了。我们来比较下2和3状态有啥区别。首先start多加了一次，end和baseValue都置为0。很容易理解为什么start会有区别，主要是因为start标识这这个词的起始位置，也就是这词的偏移量，如果确定是一个词了，那么start就要继续更新到下一个词的起始位置，如果继续还是一个词的话，那么start 位置就不能变，同样，end也是表明着词的结束位置相对于start的，所以也会置为0。相比较的话，状态2表示着end会继续自增。
#####返回来继续看Analysis
这里注意下,terms是一个双链表结构，构造函数为空，而且还是protected类型。下面第一个方法是next()方法，这个方法是取出一个term,并且更新偏移量。如果terms是空的，那就从文档中读取，并且做歧义处理，最后还是读出，更新偏移量。这里的输入是terms，输出是term。
歧义处理的方法的输入就是一个句子，将这个句子变成graph，那么我们就要先看看graph这个类了。这里只是调用了graph的构造函数，继续往下看，又多了GetWords，这个类的主要内容在SmartGetWord里面，初始化了一个森林和一句话。这个循环里面有个frontWords，，进入到该方法里面看一细看,就是返回一个数组的某一个元素。换而言之，如果我们这个字符串有子字符串在这个歧义森林里面，那么我们就能将这个term加入到图中。反之，我们就直接得到result结果，并更新terms。用一句话来说，拿到字符串了，先放到歧义森林里面检查一遍，这个歧义森林是用数组来做的成的，如果查出来了我们的句子里面有歧义森林里面的东西，那么就先进行歧义处理，将

Analysis类里面最重要的莫过于analysisStr()方法和analysis()方法，这两个方法涉及到Graph类和SmartGerWord类和SmartForest类。那么就需要好好解释下这两个方法。

#######analysisStr(String temp)
明显输入是一个句子，字符串，temp，然后构造一个图实例。
如果存在歧义的森林，那么就优先设置歧义里面的词语，否则就直接调用analysis。这两个方法里面，都会调用graph.add(term)这个方法，
GetWord这个类还好，很单纯的只跟chars, ambiguityForest联系，作为输入。

######analysis(graph.chars[], endoff)
从analysis()中获得了endoff，然后就在这个区域内作出字符串识别，包括英文的，数字的，单个字符的，以及默认的。在默认的这个case里面，是个很重要的东西，主要是剩下的汉字部分，在汉字部分，就需要在start和endoff之间取出所有的词，这个功能主要由GetWordsImpl中的allWords()得到。而这个方法里面又是充满了DATDictionary取出来的词语。
merger()方法是遍历打分的方法，意思是从从fromTerm到同一行的所有term的分数值，并将分数和from存在terms[to]。也就是说我们从terms[to]中可以获得fromTerm及其对应的分数。对于每一个terms[to]我们仅有一个fromTerm。
我们这个遍历打分的方法是在walkPath()里面被调用的，每一次都是在同一行的数据内部进行遍历打分，打完分之后，又会继续返回terms[i++]中，继续执行下一行的遍历打分。
这里我们需要区分的terms[i]和terms.next()区别。注释里面说了，next是指的是同一行的数据，而terms[i]则是下一个链表单元了。换句话说，这个存储的方法是值每一个terms[i]是一个数组，每个数组里面则是一个链表，数组里面放了一句话，链表里面放了这个分词有多少种可能。





#####graph类
构造函数就是将句子分成字符数组，并更新end,root之类的变量。这里有个很重要的问题，graph的terms链表是如何得来的？通过阅读程序，我们发现这个链表是通过Analysis类里面的analysis方法获取的。大致的意思从通过获取chars[i]的状态，通过一个状态机获取。

#####SmartForest类
关于这个SmartGetWords往里面一看，里面有一个SmartForest，再继续看下去，这东西里面最重要的就是一个数组braches和一个元素branch,这东西看起来不难。首先是添加branch的方法，就是通过二分法找到响应的索引，然后作出修改的动作而已。如果不存在就改为存在，如果存在，就改状态，设置成2,意思是这是一个词的一部分。如果索引小于0,就说明不存在，那么就一个该增加，这里的分配数组braches有点像是分配数组的形式一样。同样的加字符串也一样的。

注意一个东西，由于字典都是按照字符的当作下标的，所以字典都是有序的自增数组，也就是可以直接使用二分法查找。这里的SmartForest类就是个数组。
