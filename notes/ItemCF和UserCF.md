##ItemCF和UserCF
####ItemCF
#####想法
ItemCF的想法基于物品的相似程度，用什么东西来评判物品之间的相似程度？喜欢物品A的，大都也喜欢物品B，那么物品A和物品B就相似。获得了相似物品，那我们就要将结合用户的历史矩阵和相似物品来推荐物品。所以关键字有三个：*物品相似度*，*相似矩阵*，*历史矩阵*。两个物品属于一个用户的兴趣列表，那么可能这两个物品属于几个不同的类别，假如两个物品属于很多用户的列表，这里可以假设取一个极限，那么这两个物品可能属于一个类别。
那么如何量化物品相似度？前文说了喜欢物品A的也喜欢物品B，则两者相似，假设有物品i,j，S(x)表示喜欢物品x的集合，Num(S(x))表示喜欢x用户的集合的大小，那么我们可以用表示物品i和物品j的相似度为：
$$Sim(i,j)=\frac{Num(S(i)\bigcap{S(j)})}{Num(S(i))*Num(S(j))}$$
这里有个很好玩的东西，我们一般说用户的兴趣列表，但是这里我们需要求物品的相似度，所以我们也需要一个物品的用户列表，有点类似于全文搜索的倒排索引，依据物品求得感兴趣的用户集合。
#####实现
######如何建立物品的相似矩阵
我们建立一个矩阵，矩阵里面每一个元素w<sub>ij</sub>表示同时喜欢物品i和j的人个数，所以物品相似矩阵是一个对称矩阵，那么我们应该如何统计w<sub>ij</sub>?有一种方法就是遍历每个用户的相似矩阵，然后将每个用户的相似矩阵加起来，就是所得到的物品的相似矩阵。用伪代码表示为：
```
int simMatrix[numItem][numItem];
for(int userId : userIds) 
	for(int i : ratings[userId])
    	for(int j : ratings[userId])
        	if ( i == j ) contine;
            simMatrix[i][j]++;

```
######如何推荐
结合用户的历史，遍历用户的每一个兴趣的Item，乘以相似物品的相似程度，然后求和，排序，取最大的K个值。但是实际中往往为了减少运算程度，先选取某个兴趣的Item的最相似的K个Item，然后求和。
```
for (userItem : userHistoryItem)
	for (item : Items)
    	maxTopK(item, simMatrix[item]);
    for (item : topKItem)
       	result[item] += userItem*simMatrix[userItem][item];
topK(result[item]);
```
#####MR实现
考虑到MR的方式如何存储相似矩阵是一个问题，

#####spark实现

#####itemCF优化
######对流行度的一个折衷

######最大值归一化

####UserCF
上面的ItemCF方法是找到相似矩阵，然后结合用户历史推荐与用户历史相似的物品，这种方法更加侧重于个性化，抓住了用户的兴趣特征，进行与兴趣特征相似性推荐。而UserCF方法则是通过了寻找相似用户，推荐给那些还没有碰到过或者没有购买的物品的相似用户，这时候面临了与ItemCF相似的问题了，那就是如何判断两个用户相似度？我们在ItemCF中，使用了用户当作物品的相似度的量化单位，那我们这里就用Item当作相似度的量化单位。这里有两个表征相似度的方法，一个是通过Jaccard相似度，一个是余弦相似度：
Jaccard相似度定义为为：
$$w<sub>ij</sub> = \frac{Num(S(i)\bigcap{S(j)}}{}$$
余弦相似度

####UserCF和ItemCF的比较
ItemCF更加侧重于描述用户的个性化，是基于用户的个人兴趣作出推荐，Item只是用户兴趣的表示而已，而UserCF则是依据一个群体推荐的。对于新闻推荐，通常更加注重实效性和热门内容，所以一般采用UserCF会多点，而对于电商